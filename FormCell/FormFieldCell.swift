//
//  FormFieldCell.swift
//  FormFieldCell
//
//  Created by 須藤 将史 on 2017/02/19.
//  Copyright © 2017年 masashi_sutou. All rights reserved.
//

import UIKit

private enum LengthPattern: String {

    case none = ""
    case min = "Please enter no less than %d letters"
    case max = "Please enter no more than %d characters"
    case range = "Please enter no less than %d characters and not more than %d characters"
    
    init(_ lengthError: (min: Int, max: Int)?) {
        
        guard let lengthError = lengthError else { self = .none; return }
        
        if lengthError.min > 0 && lengthError.max == 0 {
            self = .min
            return
        }
        
        if lengthError.min == 0 && lengthError.max > 0 {
            self = .max
            return
        }
        
        if lengthError.min < lengthError.max {
            self = .range
            return
        }
        
        self = .none
    }
}

final public class FormFieldCell: UITableViewCell, UITextFieldDelegate {

    public var textField: UITextField!

    private var lengthPattern: LengthPattern = .none
    private var lengthError: (min: Int, max: Int)?
    private var pregError: (pattern: PregMatchePattern, message: String?)?
    private var isOptional: Bool = false
    
    private var beginEditing: (() -> Void)?
    private var textChanged: ((_ text: String, _ errorMessage: String?) -> Void)?
    private var didReturn: (() -> Void)?
    
    private var currentLengthLabel: UILabel!
    private var errorMessageLabel: UILabel!

    // MARK: - initialize
    
    public init(beginEditing: (() -> Void)? = nil, textChanged: ((_ text: String, _ error: String?) -> Void)? = nil, didReturn: (() -> Void)? = nil) {
        
        super.init(style: .default, reuseIdentifier: "FormFieldCell")
        self.setup(lengthError: lengthError, pregError: pregError, isOptional: isOptional)
    }
    
    public init(lengthError: (Int, Int)? = nil, pregError:(PregMatchePattern, String?)? = nil, isOptional: Bool = false) {
        
        super.init(style: .default, reuseIdentifier: "FormFieldCell")
        self.setup(lengthError: lengthError, pregError: pregError, isOptional: isOptional)
    }
    
    // MARK: - callback
    
    public func editField(beginEditing: (() -> Void)? = nil, textChanged: ((_ text: String, _ error: String?) -> Void)? = nil, didReturn: (() -> Void)? = nil) {

        self.beginEditing = beginEditing
        self.textChanged = textChanged
        self.didReturn = didReturn
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - UI Setting
    
    private func setup(lengthError:(min: Int, max: Int)?, pregError:(pattern: PregMatchePattern, message: String?)?, isOptional: Bool) {
        
        self.selectionStyle = .none
        self.accessoryType = .none
        self.accessoryView = nil
        
        self.lengthPattern = LengthPattern(lengthError)
        self.lengthError = lengthError
        self.pregError = pregError
        self.isOptional = isOptional
        
        self.textField = UITextField(frame: .zero)
        self.textField.clearButtonMode = .whileEditing
        self.textField.text = nil
        self.textField.addTarget(self, action: #selector(FormFieldCell.textFieldChanged(_:)), for: .editingChanged)
        self.textField.delegate = self
        self.contentView.addSubview(self.textField)
        
        self.currentLengthLabel = UILabel(frame: .zero)
        self.currentLengthLabel.font = UIFont.systemFont(ofSize: 10)
        self.currentLengthLabel.numberOfLines = 1
        self.currentLengthLabel.isHidden = true
        self.currentLengthLabel.textAlignment = .right
        self.textField.addSubview(self.currentLengthLabel)
        
        self.errorMessageLabel = UILabel(frame: .zero)
        if let pregError = pregError {
            if let message = pregError.message {
                self.errorMessageLabel.text = "・" + message
            } else {
                self.errorMessageLabel.text = "・" + pregError.pattern.errorMessage()
            }
        }
        
        self.errorMessageLabel.numberOfLines = 1
        self.errorMessageLabel.lineBreakMode = .byTruncatingMiddle
        self.errorMessageLabel.textColor = .red
        self.errorMessageLabel.font = UIFont.systemFont(ofSize: 10)
        self.errorMessageLabel.isHidden = true
        self.errorMessageLabel.textAlignment = .left
        self.contentView.addSubview(self.errorMessageLabel)
    }
    
    override public func layoutSubviews() {
        
        super.layoutSubviews()
        
        self.textField.frame = CGRect(x: self.layoutMargins.left, y: 0, width: self.contentView.frame.width - self.layoutMargins.left - self.layoutMargins.right - 5, height: self.contentView.frame.height)
        self.currentLengthLabel.frame = CGRect(x: self.textField.frame.width - 100, y: 2, width: 100, height: 12)
        self.errorMessageLabel.frame = CGRect(x: self.layoutMargins.left, y: self.contentView.frame.height - self.layoutMargins.bottom - 2, width: self.contentView.frame.width - self.layoutMargins.left - self.layoutMargins.right - 5, height: 12)
        self.showLabels()
    }
    
    // MARK: - UITextFieldDelegate
    
    public func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
        
        if let beginEditing = self.beginEditing {
            beginEditing()
        }
        return true
    }

    public func textFieldDidBeginEditing(_ textField: UITextField) {
        
        defer {
            if let count = textField.text?.characters.count {
                self.fix(currentTextLength: count)
            }
        }
        
        guard let lengthError = self.lengthError else { return }
        
        if lengthError.min > 0 || lengthError.max > 0 {
            self.currentLengthLabel.isHidden = false
        } else {
            self.currentLengthLabel.isHidden = true
        }
    }
    
    public func textFieldDidEndEditing(_ textField: UITextField) {
        
        guard let text: String = textField.text else { return }
        self.showLabels(text: text)
    }
    
    public func textFieldShouldClear(_ textField: UITextField) -> Bool {

        self.fix(currentTextLength: 0)
        return true
    }

    public func textFieldShouldReturn(_ textField: UITextField) -> Bool {

        guard let text: String = textField.text else {
            
            if let didReturn = self.didReturn {
                didReturn()
            }
            
            return true
        }

        self.showLabels(text: text)
        if let didReturn = self.didReturn {
            didReturn()
        }
        
        return true
    }
    
    // MARK: - change text
    
    func textFieldChanged(_ textField: UITextField) {
        
        guard let text = textField.text else { return }
        
        self.fix(currentTextLength: text.characters.count )
        
        if let textChanged = self.textChanged {
            
            if self.showCurrentLengthLabel(text: text) {
                
                guard let lengthError = self.lengthError else {
                    textChanged(text, "Length Error")
                    return
                }
                
                switch self.lengthPattern {
                case .none:
                    textChanged(text, "Length Error")
                case .min:
                    textChanged(text, String(format: self.lengthPattern.rawValue, lengthError.min))
                case .max:
                    textChanged(text, String(format: self.lengthPattern.rawValue, lengthError.max))
                case .range:
                    textChanged(text, String(format: self.lengthPattern.rawValue, lengthError.min, lengthError.max))
                }
                
            } else if self.showErrorMessageLabel(text: text) {
                
                guard let pregError = self.pregError else {
                    textChanged(text, "Length Error")
                    return
                }

                textChanged(text, pregError.pattern.errorMessage())
            } else {
                textChanged(text, nil)
            }
        }
    }
    
    // MARK: - text length count
    
    private func fix(currentTextLength: Int) {
        
        guard let lengthError = self.lengthError else {
            self.currentLengthLabel.isHidden = true
            return
        }
        
        switch self.lengthPattern {
        case .none:
            self.currentLengthLabel.isHidden = true

        case .min:
            self.currentLengthLabel.text = String(format: "%d min: %d", currentTextLength, lengthError.min)
            
            if currentTextLength < lengthError.min {
                self.currentLengthLabel.textColor = .red
            } else {
                self.currentLengthLabel.textColor = .lightGray
            }
            self.currentLengthLabel.isHidden = false
        
        case .max:
            self.currentLengthLabel.text = String(format: "%d max: %d", currentTextLength, lengthError.max)
            
            if currentTextLength > lengthError.max {
                self.currentLengthLabel.textColor = .red
            } else {
                self.currentLengthLabel.textColor = .lightGray
            }
            self.currentLengthLabel.isHidden = false
        
        case .range:
            self.currentLengthLabel.text = String(format: "%d min: %d, max: %d", currentTextLength, lengthError.min, lengthError.max)
            
            if lengthError.min...lengthError.max ~= currentTextLength {
                self.currentLengthLabel.textColor = .lightGray
            } else {
                self.currentLengthLabel.textColor = .red
            }
            self.currentLengthLabel.isHidden = false
        }
    }
    
    // MARK: - show Labels

    public func showLabels() {
        
        guard let text: String = textField.text else { return }
        self.fix(currentTextLength: text.characters.count)
        self.showLabels(text: text)
    }
    
    private func showLabels(text:String) {
        
        self.currentLengthLabel.isHidden = !self.showCurrentLengthLabel(text: text)
        self.errorMessageLabel.isHidden = !self.showErrorMessageLabel(text: text)
    }
    
    private func showCurrentLengthLabel(text: String) -> Bool {
        
        guard let lengthError = self.lengthError else { return false }
        
        let length: Int = text.characters.count
        
        switch self.lengthPattern {
        case .none:
            return false
        case .min:
            
            if length == 0 && self.isOptional {
                return false
            } else {
                return length < lengthError.min
            }
            
        case .max:
            
            if length == 0 && self.isOptional {
                return false
            } else {
                return length > lengthError.max
            }
            
        case .range:
            
            if length == 0 && self.isOptional {
                return false
            } else {
                return !(lengthError.min...lengthError.max ~= length)
            }
        }
    }
    
    private func showErrorMessageLabel(text: String) -> Bool {
        
        guard let pregError = self.pregError  else { return false }
        
        if text.characters.count == 0 && self.isOptional {
            return false
        } else {
            return !text.pregMatche(pattern: pregError.pattern)
        }
    }
}
